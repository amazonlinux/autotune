#!/usr/bin/python

'''

EC2 Amazon Linux Kernel Autotuning

This tool is a front end CLI to administer autotuning.
autotune CLI can do following:
    - List available profiles for tuning
    - Switch profiles
    - Show current active profile
    - Override tunables in user config
    - Exclude tunables in user config
    - Delete tunables in user config
    - List all config values
    - Enable autotuning
    - Disable autotuning
    - Show current status
'''

import os
import sys
import textwrap
try:
    from configparser import RawConfigParser
except ImportError:
    # Backward compatibility with python versions earlier to 3.0
    from ConfigParser import RawConfigParser
import argparse
from ec2sys_autotune.ec2_autotune_start import Ec2AutotuneStart
from ec2sys_autotune.ec2_autotune_stop import Ec2AutotuneStop
from ec2sys_autotune.ec2_instance_fetch_cfg import fetch_configuration
from ec2sys_autotune.ec2_instance_fetch_cfg import EXCLUDE_TAG
from ec2sys_autotune.ec2_autotune_utils import exec_cmds
from ec2sys_autotune.ec2_instance_exception import Ec2AutotuneError

# Config file location to autotune
CONFIG_FILE = "/etc/ec2sys-autotune.cfg"

# Current available profiles compatible with autotune
AVAILABLE_PROFILES = {
    "base": "Tunables which are generic and workload agnostic",
    "udp-server": "Tunables for UDP server in docker or containers workload",
    "placement-group": "Tunables to configure instances for high " +
                       "network speed within EC2 placement group"}


def autogenerate_profile(profile, config_dir):
    '''

    Make sure autogenerated profile exists.
    autotune.start() is optimized to reuse existing profiles
    once generated.
    '''
    autotune = Ec2AutotuneStart(genconfigonly=True)
    try:
        autotune.start()
    except Ec2AutotuneError, e:
        raise (e)

    # Validate auto generated profile config path
    auto_profile = "{0}/{1}.ini".format(config_dir, profile)
    if (os.path.isfile(auto_profile) is False):
        raise Ec2AutotuneError("Failed to generate config file {0}, "
                               "operation failed.".format(auto_profile))


def is_valid_tunable(profile, config_dir, section, tunable):
    '''

    Validate the tunable before adding it as user customized tunable.
    '''
    autogenerate_profile(profile, config_dir)

    #  Read auto generated config file (ini format)
    autocfg_object = RawConfigParser(allow_no_value=True)
    autocfg_object.read("{0}/{1}.ini".format(config_dir, profile))
    if (autocfg_object.has_section(section) is True):
        options = autocfg_object.options(section)
        for item in options:
            if (item == tunable):
                return True
    return False


def get_all_defaults_from_config(config):
    '''

    Read in all defaults
    '''
    cfg_object = RawConfigParser(allow_no_value=True)
    cfg_object.read(config)
    return cfg_object.defaults()


def get_options_from_config(config, options_needed):
    '''

    Read in the list of options requested
    '''
    cfg_object = RawConfigParser(allow_no_value=True)
    cfg_object.read(config)
    config_options = {}
    for section, option in options_needed.iteritems():
        if (cfg_object.has_option(section, option) is False):
            continue
        config_options[option] = cfg_object.get(section, option)
    return config_options


def customize_user_config(user_data, remove_op=False):
    '''

    Parse the user passed in data
    Override format: <class>:<tunable>:<value>
    Exclude format: <class>:<tunable>
    Delete format: <class>:<tunable>
    '''
    first_delim = user_data.find(":")
    second_delim = user_data.find(":", first_delim+1)
    section = user_data[:first_delim]
    tunable = user_data[first_delim+1:second_delim]
    value = user_data[second_delim+1:]
    if (section is None or tunable is None or value is None):
        raise Ec2AutotuneError("\nInvalid format, "
                               "please refer to help section.\n")

    config_defaults = get_all_defaults_from_config(CONFIG_FILE)
    try:
        config_dir = config_defaults["config_dir"]
        user_config = config_defaults["user_config"]
        options_needed = {"profile": "PROFILE",
                          section: tunable}
        config_options = get_options_from_config(
                             "{0}/{1}".format(config_dir, user_config),
                             options_needed)
        profile = config_options["PROFILE"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))

    if (section != "profile" and
            is_valid_tunable(profile, config_dir, section, tunable) is False):
        raise Ec2AutotuneError("\nInvalid tunable, "
                               "please use a valid tunable.\n")

    '''
    comment_prefixes is not available in python 2,
    use sed to retain comments in configuartion file.
    INIConfig retains comments, but does not provide any
    interface to add a new key pair of name=value nor
    provides an interface to remove key pair of name=value.
    '''

    # Remove the current customization
    cur_val = None
    try:
        cur_val = config_options[tunable]
    except KeyError, e:
        # No customization to remove
        pass
    if (cur_val is not None):
        cmd = "/bin/sed -i \'/^{0} = /d\' {1}" \
              .format(tunable,
                      "{0}/{1}".format(config_dir, user_config))
        exec_cmds([cmd])
        print("\nRemoved earlier user customization of {0}\n".format(tunable))

    if (remove_op is True):
        return

    # Add the new customization
    cmd = "/bin/sed -i \'/^\[{0}\]/ a {1} = {2}\' {3}" \
          .format(section, tunable, value,
                  "{0}/{1}".format(config_dir, user_config))
    exec_cmds([cmd])
    return


def apply_tunables():
    '''

    Apply autotune tunables
    '''

    autotune = Ec2AutotuneStart(CONFIG_FILE, False)
    try:
        autotune.start()
    except Ec2AutotuneError, e:
        raise (e)
    return


def rollback_tunables():
    '''

    Rollback autotune tunables
    '''

    autotune = Ec2AutotuneStop(CONFIG_FILE)
    try:
        autotune.stop()
    except Ec2AutotuneError, e:
        raise (e)
    return


def reapply_tunables():
    options_needed = {"DEFAULT": "STATUS"}
    config_options = get_options_from_config(CONFIG_FILE, options_needed)
    try:
        status = config_options["STATUS"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))
    if (os.path.isfile(status) is True):
        # Autotune is active, reapply to pickup new configuration
        print("\nReapplying autotune tunables to "
              "activate new configuration...\n")
        rollback_tunables()
        apply_tunables()
    return


def process_list(args):
    '''

    List available profiles to end user
    '''

    print("\nAvailable profiles for autotune:\n")
    count = 1
    for profile, description in AVAILABLE_PROFILES.items():
        print("{0:2} {1:15} - {2:60}".format(str(count),
                                             profile,
                                             description))
        count = count + 1
    print("\n")
    return


def process_profile(args):
    '''

    Switch profile to a new profile
    '''

    config_defaults = get_all_defaults_from_config(CONFIG_FILE)
    try:
        config_dir = config_defaults["config_dir"]
        user_config = config_defaults["user_config"]
        options_needed = {"profile": "PROFILE"}
        config_options = get_options_from_config(
                             "{0}/{1}".format(config_dir, user_config),
                             options_needed)
        profile = config_options["PROFILE"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))

    try:
        # Validate input profile before setting it
        description = AVAILABLE_PROFILES[args.profile]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid profile name {0}, "
                               "please use a valid profile.\n".format(str(e)))

    if (args.secured is True):
        new_profile = "{0}-secured".format(args.profile)
    else:
        new_profile = args.profile
    if (profile != new_profile):
        customize_user_config("profile:PROFILE:{0}".format(new_profile))

        '''
        After the profile is set, reapply the tunables if it has already
        been applied to pick new profile.
        '''
        reapply_tunables()
    print("\nSuccessfully changed the profile to: {0}\n".format(
          new_profile))
    return


def process_active(args):
    '''

    Show current active profile
    '''

    config_defaults = get_all_defaults_from_config(CONFIG_FILE)
    try:
        config_dir = config_defaults["config_dir"]
        user_config = config_defaults["user_config"]
        options_needed = {"profile": "PROFILE"}
        config_options = get_options_from_config(
                             "{0}/{1}".format(config_dir, user_config),
                             options_needed)
        profile = config_options["PROFILE"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))
    print("\nCurrent active profile: {0}\n".format(profile))
    return


def process_apply(args):
    '''

    Apply the tunables
    '''

    apply_tunables()
    print("\nEnabled autotune tunables\n")
    return


def process_rollback(args):
    '''

    Rollback the tunables
    '''

    rollback_tunables()
    print("\nDisabled autotune tunables\n")
    return


def process_status(args):
    '''

    Get the current status
    '''

    options_needed = {"DEFAULT": "STATUS"}
    config_options = get_options_from_config(CONFIG_FILE, options_needed)
    try:
        status = config_options["STATUS"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))
    if (os.path.isfile(status) is True):
        print("\nAutotune is active\n")
    else:
        print("\nAutotune is not active\n")
    return


def print_user_overridden(item, value):
    print("{0} = {1} [user overridden]".format(item, value))
    return


def print_user_excluded(item):
    print("{0} = [user excluded]".format(item))
    return


def print_auto_generated(item, value):
    print("{0} = {1}".format(item, value))
    return


def process_showconfig(args):
    '''

    Show proposed configurations for the active profile
    '''

    config_defaults = get_all_defaults_from_config(CONFIG_FILE)
    try:
        config_dir = config_defaults["config_dir"]
        user_config = config_defaults["user_config"]
        options_needed = {"profile": "PROFILE"}
        config_options = get_options_from_config(
                             "{0}/{1}".format(config_dir, user_config),
                             options_needed)
        profile = config_options["PROFILE"]
    except KeyError, e:
        raise Ec2AutotuneError("\nInvalid key {0}".format(str(e)))
    autogenerate_profile(profile, config_dir)

    #  Read auto generated config file (ini format)
    autocfg_object = RawConfigParser(allow_no_value=True)
    autocfg_object.read("{0}/{1}.ini".format(config_dir, profile))

    print("\nAutotune configurations for profile: {0}".format(profile))

    sections = autocfg_object.sections()
    for section in sections:
        # Ignore PROFILE header section
        if (section == "profile"):
            continue
        print("\n[{0}]".format(section))
        fetch_configuration("{0}/{1}.ini".format(config_dir, profile),
                            "{0}/{1}".format(config_dir, user_config),
                            section,
                            print_user_overridden,
                            print_user_excluded,
                            print_auto_generated,
                            None)
    print("\n")
    return


def process_override(args):
    '''

    Override auto generated configuration
    '''

    # Input format: <class>:<tunable>:<value>
    if(args.override.count(":") != 2):
        raise Ec2AutotuneError("\nInvalid override format, "
                               "please use a valid format.\n")

    customize_user_config(args.override)
    '''
    After overriding tunable, reapply the tunables if it has
    already been applied
    '''
    reapply_tunables()
    print("\nSuccessfully overrided: {0}\n".format(args.override))
    return


def process_exclude(args):
    '''

    Exclude auto generated configuration
    '''

    # Input format: <class>:<tunable>
    if(args.exclude.count(":") != 1):
        raise Ec2AutotuneError("\nInvalid exclude format, "
                               "please use a valid format.\n")

    customize_user_config("{0}:{1}".format(args.exclude, EXCLUDE_TAG))
    '''
    After excluding tunable, reapply the tunables if it has
    already been applied
    '''
    reapply_tunables()
    print("\nSuccessfully excluded: {0}\n".format(args.exclude))
    return


def process_delete(args):
    '''

    Delete previous user customized tunable
    '''

    # Input format: <class>:<tunable>
    if(args.delete.count(":") != 1):
        raise Ec2AutotuneError("\nInvalid delete format, "
                               "please use a valid format.\n")

    customize_user_config("{0}:value".format(args.delete),
                          True)
    '''
    After deleting tunable, reapply the tunables
    if it has already been applied
    '''
    reapply_tunables()
    print("\nSuccessfully deleted: {0}\n".format(args.delete))
    return


def add_arguments_and_parse():
    '''

    Autotune CLI
    '''

    desc = textwrap.dedent('''\

EC2 System Autotune

Amazon Web Services EC2 fleet hosts a wide selection of instance types
optimized to fit different customer use cases. Instance types are carved
out for varying combinations of CPU, Memory, Storage and Networking capacity
to allow customers to pick the correct instance type for their workload.

Amazon Linux Kernel provides a stable, secure and high performance execution
environment for customer applications running on Amazon EC2. Default values
for kernel tunables is not the best and optimized value for all instance
types on EC2. To provide best customer experience for Amazon Linux Kernel
consumers on EC2, EC2 System Autotune optimizes kernel tunable for different
instance types.

Usage: autotune SUBCMD <ARG>

SUBCMD      Following are sub-commands to autotune:
            list:       List available profiles
            active:     Show current active profile
            apply:      Enable autotune tunables with current active profile
            rollback:   Disable autotune tunables and restore system defaults
            status:     Show autotune status
            showconfig: Show configuration for active profile
            profile:    Switch profile
                        --secured: An optional flag to include
                                   security hardening tunables
            override:   Override auto generated config
            exclude:    Exclude auto generated config
            delete:     Delete user modified config
            E.g. autotune showconfig
            autotune apply
            autotune rollback

<ARG>       Following is the format of argument passed to autotune:
            Only sub-commands override, exclude and delete need argument
            autotune override <class>:<tunable>:<value>
            autotune exclude  <class>:<tunable>
            autotune delete   <class>:<tunable>
            <class>: Class is one of service, sysctl, sysfs, cpu
            <tunable>: Name of the tunable, e.g  vm.swappiness
            <value>: Value for the tunable, e.g 10
            E.g. autotune override sysctl:vm.swappiness:10
            autotune exclude sysctl:vm.swappiness
            autotune delete sysctl:vm.swappiness

    ''')

    parser = argparse.ArgumentParser(
                 description=desc,
                 formatter_class=argparse.RawDescriptionHelpFormatter,
                 prog="autotune")
    subparsers = parser.add_subparsers()

    # List available profiles
    parser_list = subparsers.add_parser("list")
    parser_list.add_argument("list",
                             help="List available profiles",
                             action="store_true")
    parser_list.set_defaults(func=process_list)

    # Switch profile to a different profile
    parser_profile = subparsers.add_parser("profile")
    parser_profile.add_argument("profile",
                                help="Switch profile",
                                type=str)
    parser_profile.add_argument("--secured",
                                help="Add hardening tunables to this profile ",
                                action="store_true")
    parser_profile.set_defaults(func=process_profile)

    # Show the current profile that is set
    parser_active = subparsers.add_parser("active")
    parser_active.add_argument("active",
                               help="Show current active profile",
                               action="store_true")
    parser_active.set_defaults(func=process_active)

    # Start autotune service
    parser_apply = subparsers.add_parser("apply")
    parser_apply.add_argument("apply",
                              help="Apply autotune tunables with current "
                                   "active profile",
                              action="store_true")
    parser_apply.set_defaults(func=process_apply)

    # Stop autotune service
    parser_rollback = subparsers.add_parser("rollback")
    parser_rollback.add_argument("rollback",
                                 help="Rollback autotune tunables and restore "
                                      "system defaults",
                                 action="store_true")
    parser_rollback.set_defaults(func=process_rollback)

    # Show current status of autotune on the running system
    parser_status = subparsers.add_parser("status")
    parser_status.add_argument("status",
                               help="Show autotune status",
                               action="store_true")
    parser_status.set_defaults(func=process_status)

    # List all tunables that are associated with current set profile
    parser_showconfig = subparsers.add_parser("showconfig")
    parser_showconfig.add_argument("showconfig",
                                   help="Show configuration for active "
                                        "profile",
                                   action="store_true")
    parser_showconfig.set_defaults(func=process_showconfig)

    # User can override autotune's default value as per their requirement
    parser_override = subparsers.add_parser("override")
    override_help = \
        "Override auto generated config. Format: <class>:<tunable>:<value>"
    parser_override.add_argument("override",
                                 help=override_help,
                                 type=str)
    parser_override.set_defaults(func=process_override)

    # User can exclude autotune from not modifying a tunable
    parser_exclude = subparsers.add_parser("exclude")
    exclude_help = \
        "Exclude auto generated config. Format: <class>:<tunable>"
    parser_exclude.add_argument("exclude",
                                help=exclude_help,
                                type=str)
    parser_exclude.set_defaults(func=process_exclude)

    # Remove overridden/excluded tunable and fall back to autotune defaults
    parser_delete = subparsers.add_parser("delete")
    delete_help = \
        "Delete user modified config. Format: <class>:<tunable>"
    parser_delete.add_argument("delete",
                               help=delete_help,
                               type=str)
    parser_delete.set_defaults(func=process_delete)

    return (parser.parse_args())


def main():
    args = add_arguments_and_parse()

    try:
        args.func(args)
        sys.exit(0)
    except Ec2AutotuneError, e:
        print(e.msg)
        sys.exit(-1)

if __name__ == '__main__':
    main()
